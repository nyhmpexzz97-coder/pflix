import { TypedEmitter } from "tiny-typed-emitter";
import type { RawAxiosRequestHeaders } from "axios";
declare global {
    interface Worker {
    }
    namespace WebAssembly {
        interface Module {
        }
    }
    interface WebSocket {
    }
}
interface M3U8DownloaderEvents {
    start: () => void;
    progress: (progress: {
        downloadedFile: string;
        downloaded: number;
        total: number;
    }) => void;
    paused: () => void;
    resumed: () => void;
    canceled: () => void;
    error: (error: string) => void;
    completed: () => void;
    converted: (output: string) => void;
}
export default class M3U8Downloader extends TypedEmitter<M3U8DownloaderEvents> {
    private m3u8Url;
    output: string;
    private segmentsDir;
    private queue;
    private totalSegments;
    private downloadedSegments;
    private downloadedFiles;
    status: "pending" | "running" | "paused" | "canceled" | "completed" | "error";
    private options;
    /**
     * @param m3u8Url M3U8 URL
     * @param options
     * @param options.concurrency Number of segments to download concurrently
     * @param options.segmentsDir Temporary directory to store downloaded segments
     * @param options.mergeSegments Whether to merge downloaded segments into a single file
     * @param options.convert2Mp4 Whether to convert2Mp4 downloaded segments into a single file, you must open mergeSegments
     * @param options.ffmpegPath Path to ffmpeg binary if you open convert2Mp4
     * @param options.retries Number of retries for downloading segments
     * @param options.clean Whether to clean up downloaded segments after download is error or canceled
     * @param options.headers Headers to be sent with the HTTP request
     * @param options.startIndex Start index of the segment to download
     * @param options.endIndex End index of the segment to download
     * @param options.skipExistSegments Skip download if the segment file already exists
     */
    constructor(m3u8Url: string, output: string, options?: {
        concurrency?: number;
        segmentsDir?: string;
        convert2Mp4?: boolean;
        mergeSegments?: boolean;
        ffmpegPath?: string;
        retries?: number;
        clean?: boolean;
        headers?: RawAxiosRequestHeaders;
        startIndex?: number;
        endIndex?: number;
        skipExistSegments?: boolean;
        suffix?: string;
    });
    /**
     * download M3U8 file
     */
    download(): Promise<void>;
    /**
     * pause download
     */
    pause(): void;
    /**
     * resume download
     */
    resume(): void;
    /**
     * cancel download
     */
    cancel(): void;
    /**
     * download M3U8 file
     */
    private getM3U8;
    /**
     * parse M3U8 file and return an array of URLs
     * @param m3u8Content M3U8 file content
     */
    private parseM3U8;
    private downloadSegment;
    /**
     * download TS segments
     * @param tsUrls Array of TS segment URLs
     */
    private downloadTsSegments;
    /**
     * merge TS segments into a single file
     * @param tsUrls Array of TS segment URLs
     */
    private mergeTsSegments;
    private cleanUpDownloadedFiles;
    /**
     * convert merged TS file to MP4
     * @param tsMediaPath Path to merged TS file
     */
    private convertToMp4;
    isRunning(): boolean;
}
export {};
